use regex::Regex;

#[derive(Clone,Debug)]
#[allow(dead_code)]
pub enum LlvmIr {
    Ret,
    Br,
    BrIl,
    IndirectBr,
    Switch,
    _Unreachable,//dunno
    _Invoke,//dunno
    Call,
    PHI,
    Select,
    VAArg,
    Add,
    Sub,
    Mul,
    UDiv,
    SDiv,
    URem,
    SRem,
    And,
    Or,
    Xor,
    Shl,
    LShr,
    AShr,
    ICmp,
    Alloca,
    Load,
    Store,
    GetElementPtr,
    Trunc,
    ZExt,
    SExt,
    IntToPtr,
    PtrToInt,
    BitCast,
    FNeg,
    FAdd,
    FSub,
    FMul,
    FDiv,
    FRem,
    FPTrunc,
    FPExt,
    FPToUI,
    FPToSI,
    UIToFP,
    SIToFP,
    FCmp,
    InsertValue,
    ExtractValue,
    Fence,
    InsertElement,
    ExtractElement,
    ShuffleVector,
    AtomicRMW,//borde crasha
    AtomicCmpXchg,//borde crasha
}

#[allow(dead_code)]
impl LlvmIr {
    pub fn from_string(mut s: &str) -> Option<(LlvmIr, Option<u32>)> {
        let validator = Regex::new(".+;[1-9][0-9]*").unwrap();
        let mut num: Option<u32> = None;
        if validator.is_match(s) {
            let mut parts: Vec<&str> = s.split(";").collect();
            num = Some(parts.pop().unwrap().parse::<u32>().unwrap());
            s = parts.pop().unwrap();
        }
        match s {
            "RetVoid" => Some((LlvmIr::Ret, None)),
            "Ret" => Some((LlvmIr::Ret, num)),
            "Br" => Some((LlvmIr::Br, num)),
            "Br il" => Some((LlvmIr::BrIl,num)),
            "IndirectBr" => Some((LlvmIr::IndirectBr, num)),
            "Swith" => Some((LlvmIr::Switch, num)),
            "Call" => Some((LlvmIr::Call, num)),
            "PHI" => Some((LlvmIr::PHI, num)),
            "Select" => Some((LlvmIr::Select, num)),
            "VAArg" => Some((LlvmIr::VAArg, num)),
            "Add" => Some((LlvmIr::Add, num)),
            "Sub" => Some((LlvmIr::Sub, num)),
            "Mul" => Some((LlvmIr::Mul, num)),
            "UDiv" => Some((LlvmIr::UDiv, num)),
            "SDiv" => Some((LlvmIr::SDiv, num)),
            "URem" => Some((LlvmIr::URem, num)),
            "SRem" => Some((LlvmIr::SRem, num)),
            "And" => Some((LlvmIr::And, num)),
            "Or" => Some((LlvmIr::Or, num)),
            "Xor" => Some((LlvmIr::Xor, num)),
            "Shl" => Some((LlvmIr::Shl, num)),
            "LShr" => Some((LlvmIr::LShr, num)),
            "Ashr" => Some((LlvmIr::AShr, num)),
            "ICmp" => Some((LlvmIr::ICmp, num)),
            "Alloca" => Some((LlvmIr::Alloca, num)),
            "Load" => Some((LlvmIr::Load, num)),
            "Store" => Some((LlvmIr::Store, num)),
            "GetElementPtr" => Some((LlvmIr::GetElementPtr, num)),
            "Trunc" => Some((LlvmIr::Trunc, num)),
            "ZExt" => Some((LlvmIr::ZExt, num)),
            "SExt" => Some((LlvmIr::SExt, num)),
            "IntToPtr" => Some((LlvmIr::IntToPtr, num)),
            "PtrToInt" => Some((LlvmIr::PtrToInt, num)),
            "BitCast" => Some((LlvmIr::BitCast, num)),
            "FNeq" => Some((LlvmIr::FNeg, num)),
            "FAdd" => Some((LlvmIr::FAdd, num)),
            "FSub" => Some((LlvmIr::FSub, num)),
            "FMul" => Some((LlvmIr::FMul, num)),
            "FDiv" => Some((LlvmIr::FDiv, num)),
            "FRem" => Some((LlvmIr::FRem, num)),
            "FPTrunc" => Some((LlvmIr::FPTrunc, num)),
            "FPExt" => Some((LlvmIr::FPExt, num)),
            "FPToUI" => Some((LlvmIr::FPToUI, num)),
            "FPToSI" => Some((LlvmIr::FPToSI, num)),
            "UIToFP" => Some((LlvmIr::UIToFP, num)),
            "SIToFP" => Some((LlvmIr::SIToFP, num)),
            "FCmp" => Some((LlvmIr::FCmp, num)),
            "InsertValue" => Some((LlvmIr::InsertValue, num)),
            "ExtractValue" => Some((LlvmIr::ExtractValue, num)),
            "Fence" => Some((LlvmIr::Fence, num)),
            "InsertElement" => Some((LlvmIr::InsertElement, num)),
            "ExtractElement" => Some((LlvmIr::ExtractElement, num)),
            "ShuffleVector" => Some((LlvmIr::ShuffleVector, num)),
            "AtomicRMW" => Some((LlvmIr::AtomicRMW, num)),
            "AtomicCmpXchg" => Some((LlvmIr::AtomicCmpXchg, num)),
            _ => None,
        }
    }
}